#!/usr/bin/env python3

import json
import struct
import sys

from gi.repository import Gio, GLib


def debug(msg):
    print(msg, file=sys.stderr, flush=True)


def escape_object_path(objpath):
    # We basically URI escape but instead of % we use _
    return (GLib.uri_escape_string(objpath, None, False)
            .replace(".", "%2E")
            .replace("-", "%2D")
            .replace("~", "%7E")
            .replace("_", "%5F")
            .replace("%", "_"))


def unescape_object_path(objpath):
    return GLib.uri_unescape_string(objpath.replace("_", "%"))


def make_streams_binary():
    sys.stdin = sys.stdin.detach()
    sys.stdout = sys.stdout.detach()


def decode_msg():
    # Read the message length (first 4 bytes).
    length_bytes = sys.stdin.read(4)
    if not len(length_bytes):
        # FIXME:
        sys.exit(0)

    # Unpack message length as 4 byte integer.
    length = struct.unpack('@i', length_bytes)[0]

    # Read the text (JSON object) of the message.
    text = sys.stdin.read(length).decode("utf-8")
    return json.loads(text)


def encode_msg(msg):
    try:
        text = json.dumps(msg)
    except ValueError:
        return 0

    data = text.encode("utf-8")
    length_bytes = struct.pack("@i", len(data))
    return sys.stdout.write(length_bytes) + sys.stdout.write(data)


class DBusService:
    def __init__(self, conn, path):
        self._conn = conn

        self.__reg_ids = []
        self._method_outargs = {}
        self._method_inargs = {}
        self._readable_props = {}
        self._writable_props = {}

        node_info = Gio.DBusNodeInfo.new_for_xml(self.__doc__)
        for iface in node_info.interfaces:
            method_inargs = self._method_inargs.setdefault(iface.name, {})
            method_outargs = self._method_outargs.setdefault(iface.name, {})
            for method in iface.methods:
                method_outargs[method.name] = "(%s)" % "".join(
                    arg.signature for arg in method.out_args)
                method_inargs[method.name] = tuple(
                    arg.signature for arg in method.in_args)

            readable_props = self._readable_props.setdefault(iface.name, {})
            writable_props = self._writable_props.setdefault(iface.name, {})
            for prop in iface.properties:
                if prop.flags & Gio.DBusPropertyInfoFlags.READABLE:
                    readable_props[prop.name] = prop.signature
                if prop.flags & Gio.DBusPropertyInfoFlags.WRITABLE:
                    writable_props[prop.name] = prop.signature

            self.__reg_ids.append(
                self._conn.register_object(path, iface, self.on_method_call)
            )

            self._method_inargs["org.freedesktop.DBus.Properties"] = {
                "Get": "ss",
                "GetAll": "s",
                "Set": "ssv",
            }
            self._method_outargs["org.freedesktop.DBus.Properties"] = {
                "Get": "(v)",
                "GetAll": "(a{sv})",
                "Set": "()",
            }

    def unpublish(self):
        for i in self.__reg_ids:
            self._conn.unregister_object(i)

    def on_method_call(self, conn, sender, objpath, iface_name, method_name,
                       params, invocation):

        method_inargs = self._method_inargs[iface_name]
        method_outargs = self._method_outargs[iface_name]

        # FIXME: move somewhere else
        if (objpath == "/org/mpris/MediaPlayer2"
                and iface_name == "org.freedesktop.DBus.Properties"
                and method_name == "Get"
                and params[0] == "org.mpris.MediaPlayer2.Player"
                and params[1] == "Position"):
            self._get_position(invocation)
            return

        if (objpath == "/org/mpris/MediaPlayer2"
                and iface_name == "org.freedesktop.DBus.Properties"
                and method_name == "GetAll"
                and params[0] == "org.mpris.MediaPlayer2.Player"):
            self._get_position_and_all(invocation)
            return

        args = list(params.unpack())
        for i, sig in enumerate(method_inargs[method_name]):
            if sig is "h":
                msg = invocation.get_message()
                fd_list = msg.get_unix_fd_list()
                args[i] = fd_list.get(args[i])

        try:
            res = getattr(self, method_name)(*args)

            # out_args is at least (sig)
            # We therefore always wrap the result as a tuple.
            # Refer to https://bugzilla.gnome.org/show_bug.cgi?id=765603
            res = (res,)

            out_args = method_outargs[method_name]
            if out_args != "()":
                variant = GLib.Variant(out_args, res)
                invocation.return_value(variant)
            else:
                invocation.return_value(None)

        except Exception as e:
            # TODO: Think of a better way to translate Python exception types
            # to DBus error types.
            e_type = type(e).__name__
            if "." not in e_type:
                e_type = "unknown." + e_type
            invocation.return_dbus_error(e_type, str(e))


class MirroredProperty:
    def __init__(self, attrname):
        self.attrname = attrname

    def __get__(self, obj, objtype=None):
        return getattr(obj, "_" + self.attrname)

    def __set__(self, obj, value):
        obj._send_message(self.attrname, value)


class MediaPlayer2(DBusService):
    """
    <node name="/Media_Player">
    <interface name="org.mpris.MediaPlayer2">
        <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>

        <method name="Raise"/>
        <method name="Quit"/>

        <property name="CanRaise" type="b" access="read"/>
        <property name="CanQuit" type="b" access="read"/>

        <property name="CanSetFullscreen" type="b" access="read">
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="Fullscreen" type="b" access="readwrite">
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="HasTrackList" type="b" access="read"/>
        <property name="Identity" type="s" access="read"/>

        <!--
        <property name="DesktopEntry" type="s" access="read">
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>
        -->

        <property name="SupportedUriSchemes" type="as" access="read"/>
        <property name="SupportedMimeTypes" type="as" access="read"/>
    </interface>

    <interface name="org.mpris.MediaPlayer2.Player">

        <method name="Play"/>
        <method name="Pause"/>
        <method name="PlayPause"/>
        <method name="Stop"/>

        <method name="Next"/>
        <method name="Previous"/>

        <method name="Seek">
            <arg direction="in" type="x" name="Offset"/>
        </method>

        <method name="SetPosition">
            <arg direction="in" type="o" name="TrackId"/>
            <arg direction="in" type="x" name="Position"/>
        </method>

        <method name="OpenUri">
            <arg direction="in" type="s" name="Uri"/>
        </method>

        <property name="PlaybackStatus" type="s" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="LoopStatus" type="s" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="Rate" type="d" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="Shuffle" type="b" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="Metadata" type="a{sv}" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="Volume" type="d" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="Position" type="x" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
        </property>

        <property name="MinimumRate" type="d" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="MaximumRate" type="d" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanGoNext" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanGoPrevious" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanPlay" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanPause" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanSeek" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanControl" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
        </property>

        <signal name="Seeked">
            <arg name="Position" type="x"/>
        </signal>

    </interface>
    </node>
    """

    def __init__(self, tabid, name, objpath):
        self._tabid = tabid
        self.__callbacks = {}

        self.CanRaise = False
        self.CanQuit = False

        self.SupportedUriSchemes = ["http", "https", "ftp", "file"]
        self.SupportedMimeTypes = [
            "audio/mpeg",
            "audio/x-flac",
            # TODO: add more
        ]

        self._Fullscreen = False
        self.Metadata = {}
        self.PlaybackStatus = "stopped"
        self._Rate = 1
        self._Volume = 1
        self._Position = 0
        self._Shuffle = False
        self._LoopStatus = "None"

        bus = Gio.bus_get_sync(Gio.BusType.SESSION)
        self._own_id = Gio.bus_own_name_on_connection(bus, name,
                                                      Gio.BusNameOwnerFlags.NONE)
        super().__init__(bus, objpath)

    Fullscreen = MirroredProperty("Fullscreen")
    Volume = MirroredProperty("Volume")
    LoopStatus = MirroredProperty("LoopStatus")
    Shuffle = MirroredProperty("Shuffle")
    Rate = MirroredProperty("Rate")

    def _get_position(self, invocation):
        self._send_message("query", "position")
        self._set_callback_on("position", lambda p:
                              invocation.return_value(
                                  GLib.Variant("(v)", (GLib.Variant("x", p),))
                              ))

    # FIXME:
    def _get_position_and_all(self, invocation):
        everything_else = self.GetAll("org.mpris.MediaPlayer2.Player")

        def inject_position(pos):
            everything_else["Position"] = GLib.Variant("x", pos)
            invocation.return_value(GLib.Variant("(a{sv})", (everything_else,)))

        self._send_message("query", "position")
        self._set_callback_on("position", inject_position)

    def _set_callback_on(self, prop, callback):
        self.__callbacks.setdefault(prop, []).append(callback)

    # SIGNALS
    def PropertiesChanged(self, iface_name, changed_props, invalidated_props):
        typed_changed_props = {}
        for p, value in changed_props.items():
            # FIXME: we assume that it's at least readable, will it always be?
            typ = self._readable_props[iface_name][p]
            typed_changed_props[p] = GLib.Variant(typ, value)

        self._conn.emit_signal(
            None,
            "/org/mpris/MediaPlayer2",
            "org.freedesktop.DBus.Properties",
            "PropertiesChanged",
            GLib.Variant.new_tuple(
                GLib.Variant("s", iface_name),
                GLib.Variant("a{sv}", typed_changed_props),
                GLib.Variant("as", invalidated_props)))

    def Seeked(self, position):
        self._conn.emit_signal(
            None,
            # FIXME: don't hardcode these
            "/org/mpris/MediaPlayer2",
            "org.mpris.MediaPlayer2.Player",
            "Seeked",
            GLib.Variant.new_tuple(GLib.Variant("x", position)))

    # METHODS
    def Get(self, iface_name, prop_name):
        typ = self._readable_props[iface_name][prop_name]
        prop = getattr(self, prop_name)
        return GLib.Variant(typ, prop)

    # FIXME:
    def GetAll(self, iface_name):
        iface_props = self._readable_props[iface_name]
        return {p: self.Get(iface_name, p) for p in iface_props if p != "Position"}

    def Set(self, iface_name, prop_name, value):
        self._writable_properties[iface_name][prop_name]
        setattr(self.object, prop_name, value)

    def Raise(self):
        pass

    def Quit(self):
        pass

    def OpenUri(self, url):
        pass

    def Play(self):
        self._send_message("Play")

    def Pause(self):
        self._send_message("Pause")

    def PlayPause(self):
        self._send_message("PlayPause")

    def Stop(self):
        self._send_message("Stop")

    def Seek(self, offset):
        self._send_message("Seek", offset)

    def SetPosition(self, trackid, position):
        if trackid != "/org/mpris/MediaPlayer2/TrackList/NoTrack":
            ytid = unescape_object_path(trackid[4:])
            self._send_message("SetPosition",
                               {"id": ytid, "position": position})

    def Next(self):
        self._send_message("Next")

    def Previous(self):
        self._send_message("Prev")

    def unpublish(self):
        super().unpublish()
        Gio.bus_unown_name(self._own_id)

    def _send_message(self, cmd, data=None):
        msg = {
            "tabId": self._tabid,
            "cmd": cmd,
        }
        if data is not None:
            msg["data"] = data
        encode_msg(msg)

    def _emit_changed(self, changes):
        for c in changes:
            if c == "Fullscreen":
                self.PropertiesChanged("org.mpris.MediaPlayer2",
                                       {c: getattr(self, c)}, [])
            else:
                self.PropertiesChanged("org.mpris.MediaPlayer2.Player",
                                       {c: getattr(self, c)}, [])

    def _handle_msg(self, msg):
        changes = []

        for key, val in msg["data"].items():
            if key == "id":
                track_path = "/ID/" + escape_object_path(val)
                self.Metadata["mpris:trackid"] = GLib.Variant("o", track_path)
                changes.append("Metadata")
            elif key == "url":
                self.Metadata["xesam:url"] = GLib.Variant("s", val)
                changes.append("Metadata")
            elif key == "thumb":
                self.Metadata["mpris:artUrl"] = GLib.Variant("s", val)
                changes.append("Metadata")
            elif key == "title":
                self.Metadata["xesam:title"] = GLib.Variant("s", val)
                changes.append("Metadata")
            elif key == "duration":
                self.Metadata["mpris:length"] = GLib.Variant("x", val)
                changes.append("Metadata")

            elif key == "position":
                self._Position = val
                # Position should *not* emit a Changed signal

            elif key == "seekedTo":
                self.Seeked(val)

            elif key in ("Fullscreen", "Volume", "LoopStatus", "Shuffle", "Rate"):
                setattr(self, "_" + key, val)
                changes.append(key)
            else:
                setattr(self, key, val)
                changes.append(key)

            if key in self.__callbacks:
                for cb in self.__callbacks[key]:
                    cb(val)
                del self.__callbacks[key]

        if changes:
            self._emit_changed(changes)


class Youtube(MediaPlayer2):
    # FIXME:
    __doc__ = MediaPlayer2.__doc__

    def __init__(self, tabid, name, objpath):
        self.Identity = "youtube"
        self.HasTrackList = False

        self.CanControl = True
        self.CanPlay = True
        self.CanPause = True
        self.CanSeek = True
        self.CanSetFullscreen = False

        self.MinimumRate = 0.25
        self.MaximumRate = 2

        # these are set correctly on song change
        self.CanGoNext = False
        self.CanGoPrevious = False

        self.PlaybackStatus = "stopped"
        self.Metadata = {}
        self._Position = 0
        self._Volume = 1

        self._Shuffle = False
        self._LoopStatus = "None"

        super().__init__(tabid, name, objpath)


def main():
    mainloop = GLib.MainLoop()

    # FIXME: Called twice because stdin and stdout are TextIOReader and
    # Writter; the first .detach() call makes them BufferedReader and Writter
    # and the second raw FileIO, which stdout needs to be for encode_msg.
    # Alternatively, they could remain Buffered and encode_msg could instead
    # flush; this is propably the better sollution.
    make_streams_binary()
    make_streams_binary()

    players = {}

    def message_handler(chan, condition):
        msg = decode_msg()
        debug(msg)

        if msg["type"] not in ("change", "update", "quit"):
            return True

        tabid = msg["tabId"]

        try:
            player = players[tabid]
        except KeyError:
            player = Youtube(tabid,
                             "org.mpris.MediaPlayer2.chrome",
                             "/org/mpris/MediaPlayer2")
            players[tabid] = player

        if msg["type"] == "change":
            player._handle_msg(msg)

        if msg["type"] == "update":
            player._handle_msg(msg)

        if msg["type"] == "quit":
            players[tabid].unpublish()
            del players[tabid]

        # otherwise GLib will remove our watch
        return True

    chan = GLib.IOChannel.unix_new(sys.stdin.fileno())
    chan.add_watch(GLib.IOCondition.IN, message_handler)
    chan.add_watch(GLib.IOCondition.HUP, lambda *_: mainloop.quit())

    mainloop.run()

if __name__ == '__main__':
    main()
