#!/usr/bin/env python3

import struct
import sys
import json

from gi.repository import GLib

import pydbus


def make_streams_binary():
    sys.stdin = sys.stdin.detach()
    sys.stdout = sys.stdout.detach()


def parse_message():
    stdin = sys.stdin

    # Read the message length (first 4 bytes).
    length_bytes = stdin.read(4)
    if not len(length_bytes):
        sys.exit(0)

    # Unpack message length as 4 byte integer.
    length = struct.unpack('@i', length_bytes)[0]

    # Read the text (JSON object) of the message.
    text = stdin.read(length).decode("utf-8")
    return json.loads(text)

def send_message(msg):
    stdout = sys.stdout

    try:
        text = json.dumps(msg)
    except ValueError:
        return 0

    data = text.encode("utf-8")
    length_bytes = struct.pack("@i", len(data))
    return stdout.write(length_bytes) + stdout.write(data)


def iter_messages():
    while True:
        yield parse_message()


class MediaPlayer2:
    """
    <node name="/Media_Player">
    <interface name="org.mpris.MediaPlayer2">
        <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>

        <method name="Raise">
        </method>

        <method name="Quit">
        </method>

        <property name="CanQuit" type="b" access="read">
        </property>

        <property name="Fullscreen" type="b" access="readwrite">
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="CanSetFullscreen" type="b" access="read">
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="CanRaise" type="b" access="read">
        </property>

        <property name="HasTrackList" type="b" access="read">
        </property>

        <property name="Identity" type="s" access="read">
        </property>

        <!--
        <property name="DesktopEntry" type="s" access="read">
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>
        -->

        <property name="SupportedUriSchemes" type="as" access="read">
        </property>

        <property name="SupportedMimeTypes" type="as" access="read">
        </property>
    </interface>

    <interface name="org.mpris.MediaPlayer2.Player">

        <method name="Next">
        </method>

        <method name="Previous">
        </method>

        <method name="Pause">
        </method>

        <method name="PlayPause">
        </method>

        <method name="Stop">
        </method>

        <method name="Play">
        </method>

        <method name="Seek">
            <arg direction="in" type="x" name="Offset">
            </arg>
        </method>

        <method name="SetPosition">
            <arg direction="in" type="o" name="TrackId">
            </arg>
            <arg direction="in" type="x" name="Position">
            </arg>
        </method>

        <method name="OpenUri">
            <arg direction="in" type="s" name="Uri">
            </arg>
        </method>

        <property name="PlaybackStatus" type="s" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="LoopStatus" type="s" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="Rate" type="d" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="Shuffle" type="b" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
            <annotation name="org.mpris.MediaPlayer2.property.optional" value="true"/>
        </property>

        <property name="Metadata" type="a{sv}" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="Volume" type="d" access="readwrite">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="Position" type="x" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
        </property>

        <property name="MinimumRate" type="d" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="MaximumRate" type="d" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanGoNext" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanGoPrevious" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanPlay" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanPause" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanSeek" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
        </property>

        <property name="CanControl" type="b" access="read">
            <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="false"/>
        </property>

        <signal name="Seeked">
            <arg name="Position" type="x">
            </arg>
        </signal>

    </interface>
    </node>
    """

    def __init__(self, tabid):
        self._tabid = tabid

        self.Identity = "youtube"
        self.HasTrackList = False

        self.CanRaise = False
        self.CanQuit = False
        self._Fullscreen = False
        self.CanSetFullscreen = False

        self.CanControl = True
        self.CanGoNext = False
        self.CanGoPrevious = False
        self.CanPlay = True
        self.CanPause = True
        self.CanSeek = True

        self.MinimumRate = 1
        self.MaximumRate = 1
        self._Rate = 1

        self.SupportedUriSchemes = ["http", "https", "ftp", "file"]
        self.SupportedMimeTypes = [
            "audio/mpeg",
            "audio/x-flac",
            # TODO: add more
        ]

        self.PlaybackStatus = "stopped"
        self.Metadata = {}
        self._Position = 0
        self._Volume = 1

        self._Shuffle = False
        self._LoopStatus = "None"

    @property
    def Fullscreen(self):
        return self._Fullscreen

    @Fullscreen.setter
    def Fullscreen(self, value):
        self._send_message({ "cmd": "fullscreen", "data": value })

    @property
    def Volume(self):
        return self._Volume

    @Volume.setter
    def Volume(self, value):
        self._send_message({ "cmd": "volume", "data": value })

    @property
    def Position(self):
        # FIXME: major hack
        self._send_message({ "cmd": "query", "data": "position" })
        reply = parse_message()
        if reply["type"] == "update" and "position" in reply["data"]:
            self._Position = reply["data"]["position"]
        return self._Position

    @property
    def LoopStatus(self):
        return self._LoopStatus

    @LoopStatus.setter
    def LoopStatus(self, value):
        self._send_message({ "cmd": "loop", "data": value })

    @property
    def Shuffle(self):
        return self._Shuffle

    @Shuffle.setter
    def Shuffle(self, value):
        self._send_message({ "cmd": "shuffle", "data": value })

    @property
    def Rate(self):
        return self._Rate

    @Rate.setter
    def Rate(self, value):
        self._send_message({ "cmd": "rate", "data": value })

    PropertiesChanged = pydbus.generic.signal()
    Seeked = pydbus.generic.signal()

    def Raise(self):
        pass

    def Quit(self):
        pass

    def Play(self):
        self._send_message({ "cmd": "play" })

    def Pause(self):
        self._send_message({ "cmd": "pause" })

    def PlayPause(self):
        self._send_message({ "cmd": "playpause" })

    def Stop(self):
        self._send_message({ "cmd": "stop" })

    def Seek(self, offset):
        self._send_message({ "cmd": "seekBy", "data": offset })

    def SetPosition(self, trackid, position):
        if trackid != "/org/mpris/MediaPlayer2/TrackList/NoTrack":
            self._send_message({"cmd": "setPosition",
                                "data": {"id": trackid[4:],
                                         "position": position
                                         }
                                })

    def Next(self):
        self._send_message({ "cmd": "next" })

    def Previous(self):
        self._send_message({ "cmd": "prev" })

    def _send_message(self, msg):
        msg["tabId"] = self._tabid
        send_message(msg)

    def _emit_changed(self, changed):
        self.PropertiesChanged("org.mpris.MediaPlayer2.Player", changed, [])


def main():
    make_streams_binary()

    playing = {}
    for msg in iter_messages():
        video = msg['video']
        playing[video['id']] = video
        if video['state'] == 'destroyed':
            del playing[video['id']]

        print(str(video), file=sys.stderr, flush=True)
        with open('/tmp/musicd-chrome', 'w') as fp:
            title = video['title'] if 'title' in video else ''
            fp.write(video['state'] + ' ' + title)
        with open('/tmp/musicd-chrome.json', 'w') as fp:
            info = list(playing.values())
            json.dump(info, fp, indent=4)


if __name__ == '__main__':
    mainloop = GLib.MainLoop()
    make_streams_binary()

    with open("/tmp/musicd-chrome.exc", "a") as f:
        f.write("Starting\n")

    bus = pydbus.SessionBus()
    # bus.publish("org.mpris.MediaPlayer2.chrome",
    #             ("/org/mpris/MediaPlayer2", player))

    players = {}

    def apply_message(player, msg):
        changes = []

        for key, val in msg["data"].items():
            if key == "id":
                player.Metadata["mpris:trackid"] = pydbus.Variant("o", "/ID/" + val)
                changes.append("Metadata")
            elif key == "url":
                player.Metadata["xesam:url"] = pydbus.Variant("s", val)
                changes.append("Metadata")
            elif key == "thumb":
                player.Metadata["mpris:artUrl"] = pydbus.Variant("s", val)
                changes.append("Metadata")
            elif key == "title":
                player.Metadata["xesam:title"] = pydbus.Variant("s", val)
                changes.append("Metadata")
            elif key == "duration":
                player.Metadata["mpris:length"] = pydbus.Variant("x", val)
                changes.append("Metadata")

            elif key == "hasNext":
                player.CanGoNext = val
                changes.append("CanGoNext")
            elif key == "hasPrev":
                player.CanGoPrevious = val
                changes.append("CanGoPrevious")

            # TODO: these may need to go elsewhere
            elif key == "maxRate":
                player.MaximumRate = val
                changes.append("MaximumRate")
            elif key == "minRate":
                player.MinimumRate = val
                changes.append("MinimumRate")

            elif key == "rate":
                player._Rate = val
                changes.append("Rate")
            elif key == "state":
                player.PlaybackStatus = val
                changes.append("PlaybackStatus")
            elif key == "volume":
                player._Volume = val
                changes.append("Volume")
            elif key == "shuffle":
                player._Shuffle = val
                changes.append("Shuffle")
            elif key == "loop":
                player._LoopStatus = val
                changes.append("LoopStatus")
            elif key == "fullscreen":
                player._Fullscreen = val
                # Fullscreen is an org.mpris.MediaPlayer2 property
                player.PropertiesChanged("org.mpris.MediaPlayer2",
                                         {"Fullscreen": player.Fullscreen},
                                         [])
            elif key == "seekedTo":
                player.Seeked(val)

            elif key == "position":
                player._Position = val
                # Position should *not* emit a Changed signal

        if changes:
            player._emit_changed({n: getattr(player, n) for n in changes})


    def watchfunc(chan, condition):
        msg = parse_message()
        print(msg, file=sys.stderr, flush=True)

        if msg["type"] not in ("change", "update", "quit"):
            return True

        if msg["tabId"] not in players:
            player = MediaPlayer2(msg["tabId"])
            players[msg["tabId"]] = (
                player,
                bus.publish("org.mpris.MediaPlayer2.chrome",
                            ("/org/mpris/MediaPlayer2", player)),
            )

        player = players[msg["tabId"]][0]

        if msg["type"] == "change":
            apply_message(player, msg)

        if msg["type"] == "update":
            apply_message(player, msg)

        if msg["type"] == "quit":
            players[msg["tabId"]][1].unpublish()
            del players[msg["tabId"]]

        with open("/tmp/musicd-chrome", "w") as f:
            json.dump(msg, f)

        return True

    make_streams_binary()
    chan = GLib.IOChannel.unix_new(sys.stdin.fileno())
    chan.add_watch(GLib.IOCondition.IN, watchfunc)
    # MainLoop.quit doesn't like being given extra arguments
    chan.add_watch(GLib.IOCondition.HUP, lambda *_: mainloop.quit())

    mainloop.run()

    with open("/tmp/musicd-chrome.exc", "a") as f:
        f.write("Killing\n")
